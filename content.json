[{"title":"1015.Reversible Primes","date":"2017-11-30T16:00:00.000Z","path":"2017/12/01/1015-Reversible-Primes/","text":"英文描述Reversible Primes (20) A reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.Now given any two positive integers N (&lt; 10^5) and D (1 &lt; D &lt;= 10), you are supposed to tell if N is a reversible prime with radix D.Input Specification:The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.Output Specification:For each test case, print in one line “Yes” if N is a reversible prime with radix D, or “No” if not.Sample Input:73 1023 223 10-2Sample Output:YesYesNo 中文描述反转素数 在任何数字系统中一个可以反转的素数是指这个数字在那个系统中通过“反转”也是一个素数。举个例子，一个十进制系统中的一个数字73是一个可以反转的素数，因为他的反转数字37也是一个素数。现在有任意两个正整数N（&lt; 105）和D（1 &lt; D &lt;= 10），你要求得这个这个正数N是否是D进制的反转数。输入规格：一个输入文件包含一些测试用例。每个测试用例在一行内包含两个整数N和D，当输入的N为负数时，一位这个测试文件结束了。输出规格：对于每个测试用例，如果N是一个在D进制中可以反转的素数就输出“Yes”否则就输出“No”样例输入:73 1023 223 10-2样例输出:YesYesNo 分析与解题1 输入的数字是一些十进制整数，也就是说不一定是素数，故先判断是否为素数2 如果是素数，之后翻转这个数字，之后计算翻转后的数字是不是也是素数3 翻转。题目给出的N是十进制数字，故先要把十进制数字转换为D进制数字。通过十进制变化为D进制数字的方法为：除D取余法（此处不再详细讨论）。得到的结果是一个翻转后的D进制数。再通过D进制数转换为十进制数的方法，D进制的各个位数乘上D的位置次方后再相加。D进制转换为10进制，从高位开始或者从低位开始都可以，但要需要记住D进制数字的位数。4 最后判断翻转后的十进制数字是否为素数。ps：输出格式，之前都是将所有的输出存放在数组中，通过判断数值的标志值来输出，这次看了ZJU上的代码，发现可以判断一个输出一个。在人工调试的时候，这样的输出是伴随着输入一个就输出一个进行执行的，起初以为这样是违规的，这次试验后，发现也是可以通过的，所以之后可以看情况来采用这样的方法来进行输出。关于分析与代码的构造，看了ZJU的代码，发现代码的构造条理清晰明了，这点值得学习。期间有一个点没有通过，后来调试后，发现是结构问题，并不是解决主要问题的方法，比如判断是否为素数以及十进制转D进制出了问题，是在输入格式上出现了错误，自己看了ZJU的代码后，有意识的朝着它的代码去更改，最后虽然与ZJU的代码不同，但是我发觉那个没过去的点已经通过了，所以我想问题是出在了输入结构那边。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;math.h&gt;int y[64] = &#123;0&#125;;int isprime(int p)&#123; if(p == 0 || p == 1) return 0; int i = 2; while(i &lt; p) &#123; if((p % i) == 0) return 0; i++; &#125; return 1;&#125;int main()&#123; int n, d; while(1) &#123; scanf(\"%d\", &amp;n); if(n &lt; 0) break; else scanf(\"%d\", &amp;d); if(isprime(n) == 1) &#123; //反转 int j = 0; while(n != 0) &#123; y[j] = n % d; n /= d; j++; &#125; //将反转数字转换为十进制数字 int k = 0; int sum = 0; j--; while(j &gt;= 0) &#123; sum += y[k] * (int)(pow(d, j)); j--; k++; &#125; //判断是否为素数 if(isprime(sum) == 1) puts(\"Yes\"); else puts(\"No\"); &#125; else puts(\"No\"); &#125; return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1016.Phone Bills","date":"2017-11-30T16:00:00.000Z","path":"2017/12/01/1016-Phone-Bills/","text":"英文描述Phone Bills (25) A long-distance telephone company charges its customers by the following rules:Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.Input Specification:Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day.The next line contains a positive number N (&lt;= 1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word “on-line” or “off-line”.For each test case, all dates will be within a single month. Each “on-line” record is paired with the chronologically next record for the same customer provided it is an “off-line” record. Any “on-line” records that are not paired with an “off-line” record are ignored, as are “off-line” records not paired with an “on-line” record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.Output Specification:For each test case, you must print a phone bill for each customer.Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.Sample Input:10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-lineSample Output:CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80 中文描述电话账单一个长途电话公司的收费规则如下：一个长途电话的消费是根据每分钟的价钱来定计算的，这价钱依赖于一天中的不同时段。当一个顾客开始打电话的时候，这个时间会被电话公司记录，当顾客挂断电话时，这个时间也会被记录。每个月，带有每段通话记录的账单将会发送给客户，其中每段通话是根据一天中不同时间段来计算的。你的工作是准备每月的账单和手机通话记录的一个集合。输入规则：每个输入文件包含一个测试用例。每个用例有两个部分：比率结构体和手机通话记录。比率结构体是指在一行内有24个非负数的整数，这24个整数代表着长途电话费。第一个数字代表从00:00到01:00的电话费，第二个数字代表从01:00到02:00的电话费，依次类推。第24个数字就代表着23:00到00:00的电话费。这个包含关系好像没有说清楚，比如一个人从00:30开始打电话，打到了01:22。那么我想问其中的01:00算第一个数字的费用还是算第二个数字的费用？下一行包含一个正数N(&lt;= 1000),接着是N条记录。每条记录包含一个顾客的名字（由20个字符组成不包含空格），一个时间和日期（mm：dd：hh：mm），一个单词：在线或者下线。每个测试用例，所有的数据都在一个月中。每个在线记录和下线记录是按照时间先后顺序成对出现的。任何一个没有对应下线记录的在线记录都将被忽略，任何一个没有对应在线记录的下线记录也会被忽略。输入保证至少有一对在线记录和下线记录是对应的。你可以假设在同一时间没有任何两条记录是相同的。时间采用24小时制。输出规则：对于每个测试用例，你必须每个顾客的手机账单。打印账单必须按照顾客名字的字母顺序进行打印（大写在小写）。对于每个顾客，在第一行内输出顾客名字和月份，格式如输出样例。之后打印每个时间段的电话，在一行内打印开始和结束时间和日期（dd：hh：mm），最后打印时间（分钟）和收费。没通电话必须按照时间先后顺序排序（这里默认为通话时长的递减顺序）。最后一行打印每月的总收费，格式如样例输出。样例输入：10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line样例输出：CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"HelloWorld","date":"2017-11-25T02:47:11.000Z","path":"2017/11/25/helloworld/","text":"前言在初中二年级的时候，我酷爱写作，身边有一位好友也喜欢写写东西。有一次我们两在聊天，谈到写作的事情，我向他提议说，我觉得咱两写的不能算文章，为什么这样说呢，你看我们读鲁迅，那才叫文章，如果我们写的也叫文章，那岂不是辱没了迅哥，所以我们以后如果说我们写文章，就说写字，比如，我问他，你最近写有字吗？ 2012-2013荒诞而生猛的开始在2010年我进入高中，开启了高中生活，刚好在一年半的时候我所在的高中倒闭了，我的同学们在一周之内都离开了学校，同学口中说：这儿要倒闭了。当到了开学第一周的周五的时候，我的同学们走完了，最后我卷起了铺盖回到了家中。学校之前没有任何通知，期间也没有说明，我们每位同学也没有办理任何手续，班主任没有动静。之后我进入了一所拥有普通高中和职业中专两种办学性质的学校，当时我选择了理科，因为之前在倒闭的高中并没有分科，在这里安静的度过了半年的时间。在即将迎来我高三生活的前夕，一次由校长组织的动员大会中，内容是校长鼓励我们这些来自普通高中的同学们转入职业高中就读，之后讲了很多国家对于职业学校的扶持政策。那是我第一次和校长近距离接触，会后，我走到她跟前，激动的对校长说，我要转入职业中专，学习计算机专业。校长拍了拍我的肩膀说，好同学，我现在就给你安排。之后校长找到我现在班主任和计算机班的班主任，把我这件事办好了，并指着我，鼓励大家像我学习，都转入职业高中。事后，响应那次号召的同学们只有我一个人，源于对计算机的兴趣，也恰好开了这场动员大会。至此，在2012年的9月，我开始系统的学习计算机知识。 图片中坐在第一排中间有点胖的穿着黑色裙子的女人就是开动员大会的校长老师和课程在职业高中这里，学习了四门课程，vb程序设计，计算机网络，access数据库，组装与维修，这些都是职业高考将会考试的科目。其中组装与维修于我来学是比较容易学习的，原因是之前在这方面接触的较多。在初三毕业那年我因为个人爱好，就到电脑维修店里做过学徒，当时对硬件上的基础知识知道的比较多。程序设计是自己最感兴趣的，当时就认为学习计算机的就应该是写程序的样子，计算机网络和access数据库学的很迷糊。有幸的事情是遇见了我们的vb程序设计老师，他之前是h3c的硬件开发工程师，在浙江大学读的研究生。那时我的轴的比较明显的，尤其是在自己喜欢的事情上，我有很多想法和很多问题都会向vb老师请教，然而大部分的问题他都能给我做出解答。比如那个年代流行在QQ上偷菜，我就问他，我们能够写一个自动偷菜的程序，时间到了就第一时间去偷菜。他说，这个问题是可以实现的，但需要腾讯提供给我们相应的接口，要不你就只能通过其它手段去解决了。当时我也没有明白接口是什么含义，但隐约觉得是可以实现的。接着来聊聊vb老师，有一次我喝了点啤酒去上课，vb老师叫我出去，跟我聊了聊天，说你喝酒了就别来上课，可以请假，你如果过来上课就不要喝酒。后来我再也没有喝酒后去上课，至今如此。vb老师是一个很有个性的老师，讲道理浙江大学的研究生完全可以在一线或者二线城市找个工作买个房子，至今如此。他却选择留在我们那个县城教书，有一次我们聊到这件事情，他说是为了女儿而回到了家里。刚回来那会他在我们县城里一高教书，由于与领导发生了冲突，毅然辞去了工作，来到了我们这所高中。一高是我们县城最好的高中，而我所在的高中是我们县城最差的高中，至今如此。高考后去领档案的时候我们碰见了vb老师，我邀请他一起去吃个饭，他执意拒绝了，只是对我们讲，到了大学中要努力学习。关于其他老师，我记得access老师经常对着我们大吼，说讲的清清楚楚了，你们还不懂。网络老师一看我们不懂，他就比较着急，恨不得自己将粉笔写入黑板中。有一次我们看见网络老师在看机电方面的书籍，我们问他老师下学期要教机电了吗，他说是啊，你们要学习，我也要学习了。我们组装与维修老师会利用课余时间给我讲解关于IT中的奇闻异事，比如IBM和微软的故事等诸如此类的。 图中左边是vb老师我的学习我之前是一名学渣，来到职高后，变成了学霸，至今如此，这种变化是我预料不到的事情。刚刚步入职业高中那个班级的时候我做了两手准备，一手准备是我带了很多新的作业本是用来学习用的，第二手准备是我也拿了一些课外书，如果不行我就继续回到之前的生活，安安静静的做自己的学渣，课外书是学渣的标配。这里颇想说一番关于学渣的事情，直到现在我也不想去抱怨谁，我也不后悔。我在初中二年级就放弃了学习，在此之前我也算是名列前茅。初二后，我就不在去学习了，甚至说是厌学，这应该就是大家都要经历的，青春期的叛逆。当时我一度要决定踏入社会，我看到母亲的眼泪后，还是决定了继续读书。从初二到高二成绩一直都是倒数着，现在回想起来那四年的时光，真是迷人又梦幻。言归正传，其实我想说的是我为什么变成了学渣，以及学渣的程度。接着来聊我在职高的学习，开始上课后我就着迷了。这可以用一句爱情中经常说的话来描述，情不知因何而起，一往而情深。我想现在应该是找不到高中那时的笔记了，我记忆最深刻的事情是课堂笔记。尤其在vb课程中，我把老师说的每一个字都写了本子上。高三那年，老师是带着其他同学去复习知识，对于我来说是第一次学习。在2012年10月左右，学校为我们这些职高的同学开了一个补习班，专门补文化课，也就是语文数学和英语，是有偿补课的。那时候我竟然向我家长要钱说我要参加补习班，需要300块钱。父母一定是支持的，只是他们没想到我竟然真的开始用功读书了。其实有一次关于我那四年中为什么不读书有过一次问答，家人说了利害，我对他们说我都明白，但我就是这样，我也不知道为什么不努力读书。丢了四年的文化课，又何尝是一年半载就能补救过来的呢。语文自然不用说，大家都是中国人，成绩也都差不多，套用那时的一句话，好不到哪去也差不到哪去。英语和数学可谓一塌糊涂，主要问题是厌恶。毕竟四年中这两门课程是必学的，可能是我的厌恶劲儿还没过去，你去学习那些你不喜欢的东西，真的是及其困难的。这时候恰巧我有了一个好的环境，因为那些学习好的同学们总是在一起玩，所以我们一起报补习班的几个同学总是在一起学习。在他们的带领下，我也不得不去学习数学和英语了，这可能就是大家现在常说的氛围。我记得我和王恒喜欢互相攀比学习，比如我5点起床，他就4点50起床，我下课学习，他下课也学习。当然也有互相帮助的时候，比如我组装与维修学的好，我就把相应的要塞说给他听，他数学比我好，就常常给我讲解数学题，虽然我依旧听不懂。转眼间那一年就在这样的紧张又开心的日子中度过了。现在总结起来，我倒是觉得我第一学期比第二学期要努力很多，这是我自己的感受，可是第二学期基本都是每天5点起床。高考结束后，我最想做的事情就是睡觉了，真的是最想做的事情。现在回想起来，的确是不健康的作息。每天9点半回去，5点起床，每天也就睡6到7个小时，整天处于一个鸡血状态，跑着去吃饭，跑着去学习。不过最后的成绩也是不错的，虽然我是第一年学习职高的课程，但是取得了班级前5的名次，至此我成了学霸了。等到我去回首那一年的时候我最大的收获并不是我学了多少计算机知识，而是vb老师给了我方向，让我知道了我想要的是什么。这样的努力也让我变得比之前自信了，相信只要付出就会有收获。 图中右边是我的学习战友王恒我的感想那一年的时光是无法描述的，就算时隔这么多年，我也不知道如何去评判那一年。如果没有那次荒诞的动员大会，如果我没有选择去学习计算机，如果我没有努力学习，如果我父母不支持我去职业中专，如果我高考准考证没有办下来……有时候我也在想所谓天时地利与人和可能就是那样吧。总之那年一是我这几年后的一个转折点，也可以说是我未来人生的一个转折点。 早上5点半的职教中心 我的文艺课桌 2013-2016全国计算机等级考试兰州和机器鱼GLM和SQL北京和工作不要温柔的走进那个良夜 2016-2018生活并不总是一帆风顺begin again","tags":[{"name":"生活","slug":"生活","permalink":"http://turingxi.top/tags/生活/"}]},{"title":"1009.Product of Polynomials","date":"2017-11-01T16:00:00.000Z","path":"2017/11/02/ProductOfPolynomials/","text":"英文描述Product of Polynomials (25) This time, you are supposed to find A mul B where A and B are two polynomialsInput Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.Output Specification:For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.Sample Input:2 1 2.4 0 3.22 2 1.5 1 0.5Sample Output:3 3 3.6 2 6.0 1 1.6 中文描述多项式乘积 此时，你应当在多项式A和B中求得A乘B输入规格：每个文件包含一个测试用例。每个用例占据2行，并且每一行包含一个多项式的信息：K N1 aN1 N2 aN2 … NK aNK，在多项式中K是一个非零的数字，Ni 和 aNi (i=1, 2, …, K)是指数和系数。给定1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.输出规格：对于每个测试用例你应该在一行内输出A和B的乘积，输出格式和输入格式相同。注意行末没有空格。小数点精确到一位。样例输入:2 1 2.4 0 3.22 2 1.5 1 0.5样例输出:3 3 3.6 2 6.0 1 1.6 分析与解题起初我一直在纠结这种运算是否和真正上的数学运算是相同的，所以总是有些迷惑。当通过后，我发现这种多项式乘积的运算和数学上的乘积运算完全是两回事。但是在这个题中你有得揣摩这个作者自定义的运算，又得去结合实际数学上的运算而考虑到作者没有说的事情，比如在这个题中，作者变没有说不输出系数为零的项。所以这个题在算法上没太多难度，时间全花费在了去揣摩题意。昨天晚上看到凌晨三点钟，终于把自己的代码修改成通过了的。期间也查阅了很多其他人的代码，最简单的方法是打表的方法，速度也最快，当然耗费了额外多的存储空间，我的思路是比较简单的插入和更新策略，但相比打表方法稍微复杂一些。 C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/* A*B,指数相加，系数相乘，系数为0不输出* calc() 如果指数相同就就更新系数的值* 否则就将指数和系数插入，在更新后判断* 系数是否为0，为0就删除，这样的策略是* 存在一个bug的，但题中却通过了，bug* 描述，如果输入：1 1 0和1 2 0这个算法* 会输出：1 3 0.0，此处系数为0，却输出* 关于这点题中也没有明确给出，就如实例* 中所举出的，只有1项，而对于k是输出0* 还是不输出，显然，就这测试结果来讲* 你想怎样就怎样* sort() 计算出来的结果不一定是按照系数* 递减进行输出的，故排个序。*/#include&lt;stdio.h&gt;int ex1[11]; //指数int ex2[11]; //指数double coe1[11]; //系数double coe2[11]; //系数int k1, k2;int exr[101];double coer[101];int c = 1; //最终输出的k，也就是有几项void calc()&#123; int i = 1; while(i &lt;= k1) &#123; int j = 1; while(j &lt;= k2) &#123; int te; double tc; te = ex1[i] + ex2[j]; tc = coe1[i] * coe2[j]; int k = 1; int f = 0; while(k &lt;= c) &#123; if(te == exr[k]) &#123; f = 1; coer[k] += tc; if(coer[k] == 0) &#123; c--; &#125; break; &#125; k++; &#125; if(f == 0) &#123; exr[c] = te; coer[c] = tc; c++; &#125; j++; &#125; i++; &#125;&#125;void input()&#123; scanf(\"%d\", &amp;k1); int i = 1; while(i &lt;= k1) &#123; scanf(\"%d\", &amp;ex1[i]); scanf(\"%lf\", &amp;coe1[i]); i++;; &#125; scanf(\"%d\", &amp;k2); i = 1; while(i &lt;= k2) &#123; scanf(\"%d%lf\", &amp;ex2[i], &amp;coe2[i]); i++; &#125;&#125;void output()&#123; int i = 1; printf(\"%d\", c - 1); while(i &lt;= c - 1) &#123; printf(\" %d %.1lf\", exr[i], coer[i]); i++; &#125;&#125;void sort()&#123; int i = 1; while(i &lt;= c - 1) &#123; int j = i + 1; while(j &lt;= c - 1) &#123; if(exr[i] &lt; exr[j]) &#123; int t = exr[i]; exr[i] = exr[j]; exr[j] = t; double d = coer[i]; coer[i] = coer[j]; coer[j] = d; &#125; j++; &#125; i++; &#125;&#125;int main()&#123; input(); calc(); sort(); output(); return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1008. Elevator","date":"2017-10-31T16:00:00.000Z","path":"2017/11/01/Elevator/","text":"英文描述Elevator (20) The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.Input Specification:Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.Output Specification:For each test case, print the total time on a single line.Sample Input:3 2 3 1Sample Output:41 中文描述反转素数 在我们的城市中一个高层建筑只有一个电梯。一个请求列表是有N个正数组成。在这列表中，这个数字意味着电梯会在相应的层数停止。电梯需要花费6秒上一层，花费4秒下一层。电梯在每一层停留5秒。对于一个给出的请求列表，你需要计算出电梯在这个列表中实现上上下下所花费的总时间。这个电梯从第0层开始运作，并且完成列表请求的那些层数后不用再回到0层。输入规格：每一个输入包含一个测试用例。每个用例包含一个正整数N，接着是N个正数。所有的数字小于100。输出规格：对于每个测试用例，在一行内输出电梯总运行时间。样例输入:3 2 3 1样例输出:41 分析与解题此题虽然简单，但也不好读懂题意。默认添加一个0进去，一个循环就搞定。判断第一个数和第二个数的大小，第一个数大于第二个数，电梯向下，否则电梯向上，之后进行相应的累加。 C语言实现12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int info[200];int N;int sum = 0;int main()&#123; scanf(\"%d\", &amp;N); int i = 1, t = 0; while(i &lt;= N) &#123; scanf(\"%d\", &amp;info[i]); if(info[i] &gt; t) &#123; sum += (info[i] - t) * 6 + 5; &#125; else &#123; sum += (t - info[i]) * 4 + 5; &#125; t = info[i]; i++; &#125; printf(\"%d\", sum); return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1007.Maximum Subsequence Sum","date":"2017-10-28T16:00:00.000Z","path":"2017/10/29/MaxinumSubsequence/","text":"英文描述Maximum Subsequence Sum (25) Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.Input Specification:Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.Output Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line.In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case).If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.Sample Input:10-10 1 2 3 4 -5 -23 3 7 -21Sample Output:10 1 4 中文描述最大子序列 提供一个K个整数的序列{ N1, N2, …, NK }。一个连续的子序列被定义为{ Ni, Ni+1, …, Nj }其中1 &lt;= i &lt;= j &lt;= K。最大子序列指的是一个连续的子序列中所有的元素之和最大。举一个例子，给出一个序列{ -2, 11, -4, 13, -5, -2 }，最大子序列是{ 11, -4, 13 }，最大子序列中的和为20。现在你要求得最大子序列的和的最大值，以及在最大子序列中第一个和最后一个数。输入规格：每一个输入文件包含一个测试用例。每个用例占据两行。第一行包含一个正数（K &lt;= 10000）。第二行包含K个数，数与数直接被空格间隔。输出规格：每个测试用例，在一行内输出最大和以及最大子序列中第一个和最后一个数字。这些数字必须以空格间隔，但在行末尾没有空格。在一个用例中，最大子序列不是唯一的，输出下标最小的i和j。如果K个数字都是负数，最大和被定义为0，并且你需要输出整个序列中第一个和最后一个数字。样例输入:10-10 1 2 3 4 -5 -23 3 7 -21样例输出:10 1 4 分析与解题我试着用暴力算法去写了这个，没想到竟然通过了，因此我在怀疑pat那些你只要能想出办法解决的，也不用太去考虑效率的事情，也就是说，你无论使用什么算法，很少会内存溢出或者时间超时。刚才去看了《算法导论》关于这个问题的出处，在第四章分治策略中出现的，刚好那是写了时间测试，暴力和分治的差别还是很大的，尤其在输入规模巨大的时候，当数据量在10w时候，分治是0.01秒，暴力是15秒。刚好这个题是1w，要求是0.4秒，我测了1w中暴力的数据基本在0.3秒和0.2秒之间，所以飘过了。分治的策略的确是很厉害的，这里我在说一遍，分治是把这个最大数组分成2个数组，之后分别求这两个子数组中最大子序列，其实我刚看了《算法导论》中分别求子序列的算法，其实也是基于暴力的，所以我常认为暴力是基本算法，分治的策略却把他分开来算，分别求的2个数组，分治总提到关键的一点，最大子数组必然位于左或右两个数组中或者跨越了这两个数组，他只对其中跨越这两个子数组的问题进行了处理，其余的情况使用了递归进行编写，昨天通过演绎的手法对代码进行了运行，虽然比较麻烦，但也看明白了代码的运行策略。分治这玩意确实很厉害，就在这个求最大子序列的问题上，他的策略的确很牛，我刚刚讲到暴力算法是基础算法，其实并不是的，起码在这个分治算法是不是的，但终其最基本的算法是比较，比较也算不是一个算法，可以说是方案。在此我再来谈谈分治。我还是通过演绎的方法吧，我的水平可能也归纳不来。就好比3，4，5。这个序列，分治的前提推论是最大子序列必然位于：{3}、{5}和{3，4，5}这三个子序列中，之后它开始分别求这3个子序列，因为{3}和{5}这两个子序列的求解同原问题求解相同，这也就是DP中谈到的最优子结构，因为原问题就是求某一个序列的最大子序列，所以{3}和{5}这两个子序列可以递归去求，而第三个子序列{3，4，5}，是表明，要求子序列一定是跨越了{3}和{5}这两个子序列，所以最大子序列必然位于{3，4}和{5}这两个子序列之间，这一点我感觉自己也讲不明白，我看了原文中写的是找到{3，4}和{5}这两个子序列的最大子序列之后将其合并，关键就在于这个合并，以及他在寻找{3，4}这个最大子序列时的顺序，是相当迷人的，这个问题你咋一听其实也是寻找{3，4，5}这个序列的最大子序列，但这个问题是加了前提的，前期就是最大子序列必然是跨越了左子序列{3}和右子序列{4}的，因为这个序列就是跨越了左和右的，因为左部最大子序列的值为3下标是1，1，右边最大子序列值为5下标是3，3。因此这个最大子序列是跨越了这两个子序列的，也就是在{3，4，5}这个子序列中的。啰嗦了一堆，我还是举个例子来表明，假如有这样一个子序列{1，2，-4，4，5}，这个子序列的最大子序列是在右边的，也就是{4，5}。那么这个子序列也要求的中点为3将这个序列分开的两个子序列{1，2，-4}和{4，5}这两个子序列的最大子序列，之后将其合并，其实我感觉这里的两个子序列的最大子序列是有一些歧义的，因为最大子序列有左和右的说法，这里其实是先求得左，再求得右，之后将其合并，也就是说{1，2，-4，4，5}返回的最大子序列的值是8，下标是1和5，所以这个问题的描述虽然是求得它的最大子序列，但限制的条件是跨越了中点的。因此分治的本质和暴力的思路是不同的，暴力就是穷举，分治是先考虑问题结构，之后与子问题进行连接，之后再原问题与子问题直接找到连接的限制，再去求解问题。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;int info[10001]; //sequenceint k = 10000;int max = 0;int first; int last;int check = 0; //check为0的话，意味着全是负数void input()&#123; scanf(\"%d\", &amp;k); int i = 1; while(i &lt;= k) &#123; scanf(\"%d\", &amp;info[i]); if(info[i] &gt;= 0) check = 1; i++; &#125;&#125;void calc()&#123; int i = 1, j = 1, sum = 0; while(i &lt;= k) &#123; sum = 0; j = i; while(j &lt;= k) &#123; sum = sum + info[j]; if(max &lt; sum) &#123; max = sum; first = i; last = j; &#125; j++; &#125; i++; &#125;&#125;int main()&#123; input(); if(check == 0) printf(\"%d %d %d\", 0, info[1], info[k]); else &#123; calc(); printf(\"%d %d %d\", max, info[first], info[last]); &#125; return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1006.Sign In and Sign Out","date":"2017-10-27T16:00:00.000Z","path":"2017/10/28/Sigin/","text":"英文描述Sign In and Sign Out (25) At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.Input Specification:Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:ID_number Sign_in_time Sign_out_timewhere times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.Output Specification:For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.Sample Input:3CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40Sample Output:SC3021234 CS301133 中文描述登录和退出 在每一天开始的时候，第一个来的人将要打开计算机教室门上的锁，最后一个离开的人将要锁住计算机教室的门。给出一个进门与出门的记录，你要找出那天中谁把门打开了和谁把门锁住了。输入规格：每一个输入文件包含一个测试用例。每个用例包含了一天的记录。这个用例的第一行是一个正整数M，代表一共有多少条记录，接着是M行，每一行的格式为：身份号码 进入时间 出去时间时间的格式为：小时：分钟：秒数，身份号码是一个不超过15个字符的字符串。输出规格：对于每一个测试用例，在一行内输出这一天中开门和关门的人的身份号码，两个身份号码之间需要被一个空格间隔开来。注意：开门和关门的人的记录一定是存在的。每个人的开门时间必须早于关门时间，没有两个人的开门或者关门时间是相同的。样例输入:3CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40样例输出:SC3021234 CS301133 分析与解题找出最早的登录时间和最晚的退出时间。使用一个二维字符数组来存储这些内容，之后从这个字符数组中解析出ID和登录时间和退出时间，接着对这些时间进行选择，选择最早的登录时间和最晚的退出时间取其ID。想起来挺简单，但写起来是有些复杂的，后来看到strcmp函数可以直接进行判断，用strcmp函数比较简单，其实在输入的时候也是可以进行判断的，关于数据结构和scanf函数的应用，ZJU那个算法写的很不错，以后会多借鉴一下那些技巧。自己在思考使用函数来存储，以及如何去接受来自文件的输入时，策略总是太差，原因也就是对那么函数不太熟悉。比如scanf是以空格和回车结束的，gets是以回车作为结束的。 C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;stdio.h&gt;#include&lt;string.h&gt;char info[1000][1000];int M;char first[9] = &#123;'9', '9', ':', '9', '9', ':', '9', '9'&#125;;char *fst = first;int fs = 0;char last[9] = &#123;'0', '0', ':', '0', '0', ':', '0', '0'&#125;;int ls = 0;char *l = last;void input()&#123; scanf(\"%d\", &amp;M); int i = 1; getchar(); while(i &lt;= M) &#123; gets(info[i]); i++; &#125;&#125;void calc(int f)&#123; int i = 1; while(i &lt;= M) &#123; char (*p) = info[i]; while(*p) &#123; if(*p == ' ') &#123; fst = first; char *cin = p + 1; char *in = p + 1; while(*in) &#123; if(f == 1) &#123; //sign out time if(*in == ' ') &#123; l = last; char *cout = in + 1; char *out = in + 1; while(*out) &#123; //seek last person if(*l &lt; *out) &#123; //out copy to last memcpy(last, cout, 9); //remark last subscript ls = i; break; &#125; else if(*l == *out) &#123; l++; out++; &#125; else break; &#125; &#125; &#125; else &#123; //seek first person if(*fst &gt; *in) &#123; //out copy to last memcpy(first, cin, 8); first[8] = '\\n'; //remark last subscript fs = i; &#125; else if(*fst == *in) &#123; fst++; &#125; else break; if(*in == ' ') break; &#125; in++; &#125; break; &#125; p++; &#125; i++; &#125;&#125;void output()&#123; fst = info[fs]; while(*fst) &#123; if(*fst == ' ') break; printf(\"%c\", *fst); fst++; &#125; putchar(' '); l = info[ls]; while(*l) &#123; if(*l == ' ') break; printf(\"%c\", *l); l++; &#125;&#125;int main()&#123; input(); calc(1); calc(0); output(); return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1005. Spell It Right","date":"2017-10-26T16:00:00.000Z","path":"2017/10/27/Spell/","text":"英文描述Reversible Primes (20) Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.Input Specification:Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10^100).Output Specification:For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.Sample Input:12345Sample Output:one five 中文描述正确拼写 给出一个非负的正数N，你的任务是去计算N的所有数字的和，并且用英语输出和的每一个数字。输入规格：每一个输入文件包含一个测试用例。每个用例占据一行包含一个非负整数输出规格：对于每一个测试用例，在一行内用英语字母输出这个和的数字。连续的字母用空格隔开，但是在行尾没有额外的空格。样例输入:12345样例输出:one five 分析与解题最大的和为3位数字，是一个99位的正数，且每位数字为9，也就是：99999……99999，一共99位，故最大的值为99 * 9 = 819。字符串作为输入，累积每个数字的和存放在整形变量sum中。之后求出这个三位数字每一位的数字，进行判断，之后输出，因为数字位数比较少，做4个判断即可正确输出。首先判断百位是否为0，若为零，则只输出十位和个位，否则就输出百位、十位和个位。同理，最后去判断十位即可。 C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;void output();char in[1000];char *p = in;int a1, a2, a3;void calc()&#123; int sum = 0; while(*p) &#123; sum += (*p - 48); p++; &#125; a1 = sum / 100; //百 a2 = (sum / 10) % 10; //十 a3 = sum % 10; //个 if(a1 == 0) &#123; if(a2 == 0) output(a3); else &#123; output(a2); printf(\" \"); output(a3); &#125; &#125; else &#123; output(a1); printf(\" \"); output(a2); printf(\" \"); output(a3); &#125;&#125;void output(int a2)&#123; if(a2 == 0) printf(\"zero\"); else if(a2 == 1) printf(\"one\"); else if(a2 == 2) printf(\"two\"); else if(a2 == 3) printf(\"three\"); else if(a2 == 4) printf(\"four\"); else if(a2 == 5) printf(\"five\"); else if(a2 == 6) printf(\"six\"); else if(a2 == 7) printf(\"seven\"); else if(a2 == 8) printf(\"eight\"); else printf(\"nine\");&#125;int main()&#123; scanf(\"%s\", in); calc(); return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1004.Counting Leaves","date":"2017-10-19T16:00:00.000Z","path":"2017/10/20/Counting/","text":"英文描述Counting Leaves (30) A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.Input Specification:Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format:ID K ID[1] ID[2] … ID[K]where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.Output Specification:For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line.Sample Input:2 101 1 02Sample Output:0 1 中文描述统计叶子 一个家庭等级体系通常被一个描述为一个家谱树被提出。你的工作是统计那些没有孩子的家庭成员。输入规格：每个输入文件包含一个测试用例。每个用例开始的一行包含N和M，N(0 &lt; N","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1003.Emergency","date":"2017-10-18T11:11:03.000Z","path":"2017/10/18/Emergency/","text":"英文描述Emergency (25) As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, you job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N(&lt;= 500) – the number of cities(and the cities are numbered from 0 to N – 1), M – the number of roads, C1 and C2 – the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.Sample Input:5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1Sample Output:2 4 中文描述紧急情况 身为一个城市的紧急救援队的领导，你应该为你的国家提供一张特殊的地图。这张地图展示了被道路连接着的一些散落的城市。每座城市救援队的总数和每对城市之间道路的长度被标记在地图上。当其他城处于紧急状况呼叫你的时候，你的工作是领导你的救援队尽可能快的赶到处于紧急状况的城市，与此同时竟可能多的呼叫正在路上的救援队。输入规格：每个文件包含一个测试用例。对于每一个测试用例，第一行包含4个整数：N（ &lt;= 500）- 城市的数量（城市标号范围从0到N – 1），M – 道路的数量，C1和C2 – 你当前所在城市和你必须营救的城市。下一行包含N个整数，第i个整数代表第i城市中营救队的数量。此外的M行中，每一行描述由3个整数c1，c2和L组成的一条道路，c1和c2是一对被一条道路连接的城市，L是这条路的长度。此测试用例保证C1和C2之间至少存在一条道路。输出规格：对于每一个测试用例，在一行内输出2个数：C1和C2之间不同最短路径的数量和你可能召集的最大的营救队总数。在一行内的所有数字必须被一个额外的空格间隔开来并且在这个行的末尾没有额外的空格。样例输入:5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1样例输出:2 4 分析与解题问题：1. 求最短路径条数。2. 在多条最短路径中，求节点权值（营救队数量）之和的最大值。根据最短路径中上界性质：设G = (V , E)为一个带权重的有向图，其权重函数由w：E→R给出，其源节点为s，改图由算法INITIALIZE-SINGLE-SOURCE(G, s)执行初始化。那么对于所有的节点v∈V，v.d &gt;= δ(s, v)，并且该不变式在对图G的边进行任何次序的松弛过程中保存成立。而且，一旦v.d取得其下届δ(s, v)后，将不再发生变化。简要解释一下这个性质的含义。提出这个性质的问题描述是这样的：最短路径估计的值将会如何变化（最短估计路径也就是性质中的d值）。结论中的δ函数是指源节点到v节点的最短路径（注意此处是最短路径，并非最短路径估计值），也就是说最短估计路径的的值d（此后将用d来描述）将永远大于或者等于最短路径值。讲到这里需要提一下最短路径的引理：三角不等式，δ(s, v) &lt;= δ(s, u) + w(u, v)，这个例子我采用一种比较通俗的语言来解释，假设源节点s到目标节点d，存在一条最短路径p，p路径途径（u，v）这条边，也就是这条路径中是先到达u后到达v，那么也就是说，s到v的最短路径永远小于或者等于s到u的最短路径加上(u，v)这条路径本身的长度。举个生活中的例子，假如你从北京到广东，途径郑州和长沙，也就是说从北京到长沙的距离永远小于或者等于从北京到郑州的距离加上郑州到长沙的距离，也就是公式的由来δ(s, v) &lt;= δ(s, u) + w(u, v)。接着，我们需要讲述另一个话题：松弛，所谓松弛也就是说根据情况来更新d的值，当一条边（u, v）中，如果v.d &gt;= u.d + w(u, v)时就来更新v.d的值，令v.d = u.d + w(u, v)。通俗点讲是这样的，你从北京到郑州，有两条路，一条为北京-邯郸-郑州，另一条为北京-拉萨-郑州，当你算了一下北京到邯郸474km，北京-拉萨-郑州4064km，假如此刻v.d是4064km也就是北京-拉萨-郑州这条路，当你去查看u.d + w(u, v)时，也就是北京-邯郸为u.d，w(u, v)为邯郸到郑州的距离252，当4064 &gt;= 474 + 252，也就是北京-拉萨-郑州这条路，要比北京-邯郸-郑州要长时，你就会去选择北京-邯郸-郑州这条路。言归正传，我们可以把上界性质中的d理解为三角不等式中的δ(s, u) + w(u, v)，所以说，d将永远大于或者等于δ。此处有一个隐含了的条件。也就是v.d = δ(s, v)时候，v.d的值将不再变化。因此你可以利用这一点来求的多条最短路径，也就是说，当你发现v.d == u.d + w(u, v)时，意味着已经找到了两条相同的最短路径。 C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188/* Emergency:shortest path* 图结构采用邻接表，最短路径算法采用dijkstra* init() 初始化操作，将除了源节点外的其他节点 d值赋值无穷，营救小队最大值初始化为0* relax() 如果v.d的值大于v.d + w(u, v)将v.d赋 值为v.d + w(u, v), 将v.maxamount = u.maxamount + v.rescue, 将v.shortsum = u.shortsum 如果v.d == v.d + w(u, v), v-&gt;shortsum = v-&gt;shortsum + u-&gt;shortsum, 如v-&gt;maxamount 小于u-&gt;maxamount + v-&gt;rescue的话，将 v-&gt;maxamount = u-&gt;maxamount + v-&gt;rescue*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct arcnode&#123; int length; int info; //城市标号 struct arcnode *next;&#125;arcnode;typedef struct vernode&#123; int d; int info; //城市标号 int shortsum; //最短路径条数 int maxamount; //不同最短路径营救小队最大值 int rescue; //每座城市营救小队数量 int visited; //最小优先队列使用 arcnode *next;&#125;vernode;typedef struct&#123; vernode vertex[502]; int versum, arcsum;&#125;AdjList;void init(AdjList *G, vernode *s)&#123; int i = 1; while(i &lt;= G-&gt;versum) &#123; G-&gt;vertex[i].d = 65536; G-&gt;vertex[i].maxamount = 0; //营救小队最大值初始化 G-&gt;vertex[i].visited = 0; //访问标记 i++; &#125; s-&gt;d = 0; s-&gt;shortsum = 1; s-&gt;maxamount = s-&gt;rescue;&#125;void relax(vernode *u, vernode *v, int weight)&#123; if(v-&gt;d &gt; (u-&gt;d + weight)) &#123; v-&gt;d = (u-&gt;d + weight); v-&gt;maxamount = v-&gt;rescue + u-&gt;maxamount; v-&gt;shortsum = u-&gt;shortsum; &#125; else if(v-&gt;d == (u-&gt;d + weight)) &#123; v-&gt;shortsum += u-&gt;shortsum; if(v-&gt;maxamount &lt; (u-&gt;maxamount + v-&gt;rescue)) v-&gt;maxamount = u-&gt;maxamount + v-&gt;rescue; &#125;&#125;vernode *search(AdjList *G, arcnode *e)&#123; int i = 1; while(i &lt;= G-&gt;versum) &#123; if(G-&gt;vertex[i].info == e-&gt;info) return &amp;G-&gt;vertex[i]; i++; &#125;&#125;vernode *findmin(AdjList *G)&#123; int i = 1; int min = 65536; while(i &lt;= G-&gt;versum) &#123; if(G-&gt;vertex[i].visited != 1) &#123; //search for min if(min &gt; G-&gt;vertex[i].d) min = G-&gt;vertex[i].d; &#125; i++; &#125; i = 1; while(i &lt;= G-&gt;versum) &#123; if(G-&gt;vertex[i].visited != 1) &#123; if(min == G-&gt;vertex[i].d) &#123; G-&gt;vertex[i].visited = 1; return &amp;G-&gt;vertex[i]; &#125; &#125; i++; &#125;&#125;void dijkstra(AdjList *G, vernode *s)&#123; init(G, s); int i = 1; while(i &lt;= G-&gt;versum) &#123; vernode *u = findmin(G); arcnode *e = u-&gt;next; while(e != NULL) &#123; vernode *v = search(G, e); relax(u, v, e-&gt;length); e = e-&gt;next; &#125; i++; &#125;&#125;void insert(vernode *L, arcnode *x)&#123; x-&gt;next = L-&gt;next; L-&gt;next = x;&#125;void input(AdjList *G, int *source, int *destination)&#123; scanf(\"%d%d%d%d\", &amp;G-&gt;versum, &amp;G-&gt;arcsum, source, destination); int i = 1; while(i &lt;= G-&gt;versum) &#123; scanf(\"%d\", &amp;G-&gt;vertex[i].rescue); G-&gt;vertex[i].info = i - 1; G-&gt;vertex[i].next = NULL; i++; &#125; i = 1; int s, d, w; while(i &lt;= G-&gt;arcsum) &#123; scanf(\"%d%d%d\", &amp;s, &amp;d, &amp;w); int j = 1; while(j &lt;= G-&gt;versum) &#123; if(s == G-&gt;vertex[j].info) &#123; arcnode *p = (arcnode*)malloc(sizeof(arcnode)); p-&gt;info = d; p-&gt;length = w; insert(&amp;G-&gt;vertex[j], p); &#125; if(d == G-&gt;vertex[j].info) &#123; arcnode *p = (arcnode*)malloc(sizeof(arcnode)); p-&gt;info = s; p-&gt;length = w; insert(&amp;G-&gt;vertex[j], p); &#125; j++; &#125; i++; &#125;&#125;void output(AdjList *G, int destination)&#123; printf(\"%d %d\\n\",G-&gt;vertex[destination].shortsum, G-&gt;vertex[destination].maxamount);&#125;void emergency()&#123; AdjList a; int s, d; input(&amp;a, &amp;s, &amp;d); if(s != d) &#123; dijkstra(&amp;a, &amp;a.vertex[s + 1]); output(&amp;a, d + 1); &#125; else &#123; printf(\"%d %d\\n\", 1, a.vertex[d + 1].rescue); &#125;&#125;int main()&#123; emergency(); return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1002.A + B for Polynomials","date":"2017-08-12T02:54:48.000Z","path":"2017/08/12/Polynomials/","text":"英文描述A + B for Polynomials(25) This time, you are supposed to find A+B where A and B are tow polynomials.Input Specification:Each input file contains one test case. Each case occupies lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2……NK aNK, where K is number of nonzero terms in the polynomial, Ni and aNi(i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt;… N2 &lt; N1 &lt;=1000.Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice must be NO extra space at the end of each line.Please be accurate to 1 decimal palce.Sample Input:2 1 2.4 0 3.22 2 1.5 1 0.5Sample Output:3 2 1.5 1 2.9 0 3.2 中文描述多项式A + B 已知多项式A和B，求A+B输入规格：每一个输入文件包含一个测试用例。每一个用例占据了一些行，每一行包含了一个多项式的信息：K N1 aN1 N2 aN2…NK aNK，在多项式里K是一个非零项，Ni和aNi(i=1, 2, … ,K)是指数和系数。设1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000。输出规格：对于每一个测试用例在一行内输出，输出格式同输入格式相同。输出的最后一个字符不能是空格。小数点精确都后1位。样例输入:73 1023 223 10-2样例输出:YesYesNo 分析与解题根据样例输入和输出初步得到，输入第一行为多项式A，输入第二行为多项式B，输出结果是合并同类项相关操作：指数相同系数相加减。隐含条件，如果系数为0则不用输出此项。例如：A = 3^2 + 0 ^3；B = 4^2，则结果A+B = 7^2。输入。根据条件Ni and aNi(i=1, 2, …, K)，用一个整形数字来接受输入数据K。定义结构体数组，来接受输入数据Ni和aNi。计算。结构体数组A代替多项式A，结构体数组B代替多项式B。求A + B，如果A中指数同B中指数相同，则将A + B的系数存放在B中，否则，将A中指数和系数插入到B中。遍历数组A，查找A中每一个指数是否在B中出现，如果出现就更新B数组中系数的值，否则就将A数组中指数和系数插入到B数组。因此，定义三个辅助函数。Search（）：查找结构体数组A是否包含指数x；Update（）：根据指定下标更新系数值；Insert（）：将指定指数和系数插入到结构体数组中。考虑隐含条件，将B中系数不等于0的提取出，存放在C中。输出。将结构体数组C输出。 C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/* A + B for Polnomials * Input() 输入多项式* Output() 输出多项式* Search() 查找指数值，成功返回下标，失败返回-1* Update() 根据下标更新数组中系数* Insert() 向数组中插入指数和系数（有序表中插入元素使之依然有序）* Calc() 计算多项式A + B，并将结果存在多项式B中* DeleteForCore() 将Calc()计算结果多项式B中系数为0的数剔除，返回最终结果多项式C*/#include&lt;stdio.h&gt;typedef struct&#123; int exp[30]; double coe[30]; int size;&#125;FA;void Input(FA *a)&#123; int k = 0; scanf(\"%d\", &amp;k); int i = 0; while(i &lt; k) &#123; scanf(\"%d%lf\", &amp;a-&gt;exp[i], &amp;a-&gt;coe[i]); i++; &#125; a-&gt;size = k;&#125;void Output(FA *a)&#123; if(a-&gt;size != 0) &#123; int i = 0; printf(\"%d\", a-&gt;size); while(i &lt; a-&gt;size) &#123; printf(\" %d %.1f\", a-&gt;exp[i], a-&gt;coe[i]); i++; &#125; puts(\"\"); &#125;&#125;int Search(FA *a, int exp)&#123; int i = 0; while(i &lt; a-&gt;size) &#123; if(a-&gt;exp[i] == exp) return i; i++; &#125; return -1;&#125;void Update(FA *a, int subscript, double coe)&#123; a-&gt;coe[subscript] += coe;&#125;void Insert(FA *a, int exp, double coe)&#123; int i = a-&gt;size - 1; a-&gt;size += 1; while(i &gt;= 0) &#123; a-&gt;exp[i + 1] = a-&gt;exp[i]; a-&gt;coe[i + 1] = a-&gt;coe[i]; if(a-&gt;exp[i] &gt; exp) &#123; a-&gt;exp[i + 1] = exp; a-&gt;coe[i + 1] = coe; return ; &#125; i--; &#125; a-&gt;exp[0] = exp; a-&gt;coe[0] = coe;&#125;FA DeleteForCoe(FA *a)&#123; int i = 0; int size = a-&gt;size; FA c; c.size = 0; while(i &lt; a-&gt;size) &#123; if(a-&gt;coe[i] != 0) &#123; c.exp[c.size] = a-&gt;exp[i]; c.coe[c.size] = a-&gt;coe[i]; c.size++; &#125; i++; &#125; return c;&#125;void Calc(FA *a, FA *b)&#123; int i = 0; int t = 0; while(i &lt; a-&gt;size) &#123; t = Search(b, a-&gt;exp[i]); if(t != -1) Update(b, t, a-&gt;coe[i]); else Insert(b, a-&gt;exp[i], a-&gt;coe[i]); i++; &#125;&#125;int main()&#123; FA a; FA b; Input(&amp;a); Input(&amp;b); Calc(&amp;a, &amp;b); FA c = DeleteForCoe(&amp;b); Output(&amp;c); return 0;&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]},{"title":"1001.A + B Format","date":"2017-07-12T02:31:11.000Z","path":"2017/07/12/Format/","text":"英文描述1001.A + B Format (20) Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where -1 000 000 &lt;= a, b &lt;= 1 000 000. The numbers are separated by a space.Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.Sample Input:-1000000 9Sample Output:CYJJ 01-999,991 中文描述电话账单用标准的格式输出a + b和，标准格式是这样的：3个数字为一组，通过逗号间隔，如果测试用例少于四个数字就不用间隔。输入规则：每个输入文件包含一个测试用例。每个测试用例是一对整数，a和b，a、b的取值范围是-1000000到1000000.a、b之间用空格间隔。输出规则：对于每个测试用例，你应该在一行内输出a+b的和。和必须用标准格式输出。样例输入：-1000000 9样例输出：-999,991 分析与解题这是开始刷的第一个题，当时写了两个多星期，并且下面的代码是第三次重构，第一次写了400多行，我也是醉醉的。后来看了ZJU的代码只有几十行我就更是醉醉的了。我真不是一个聪明的人，要不也不会写这么多代码了。 C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAXLEN 15 typedef struct&#123; char value[MAXLEN]; char pn; char len;&#125;Number;Number a, b, sum;void Initialize();void DelForSubscrip(char *p, int subscrip);void InsForSubscrip(Number *p, int subscrip, char value);void DorpForSign(char *p);void ZeroFill(Number *p, int num);void Format(Number *p); //正序格式char Compare(char *p1, char *p2); //返回0，p1大，返回1,p2大void Operation();void Addition(Number *p1, Number *p);void Carry(char *p);void ReversalStr(char *p);void Subtraction(Number *p1, Number *p2);void Borrow(char *p, int i);int Output(Number *p);int main()&#123; Initialize(); Operation(); Output(&amp;sum); return 0;&#125;void Initialize()&#123; scanf(\"%s %s\",a.value, b.value); //符号位初始化 if(a.value[0] == '-') &#123; a.pn = 0; //除去符号位 DelForSubscrip(a.value, 0); &#125; else a.pn = 1; if(b.value[0] == '-') &#123; b.pn = 0; //除去符号位 DelForSubscrip(b.value, 0); &#125; else b.pn = 1; //长度初始化 a.len = strlen(a.value); b.len = strlen(b.value); //补零操作 if(a.len &gt; b.len) //b 补 ZeroFill(&amp;b, a.len - b.len); else //a补 ZeroFill(&amp;a, b.len - a.len);&#125;void ZeroFill(Number *p, int num)&#123; int i = 0; for(; i &lt; num; i++) InsForSubscrip(p, 0, '0');&#125;void DelForSubscrip(char *p, int subscrip)&#123; int i = subscrip; int l = strlen(p) - subscrip; for(; i &lt; l; i++) p[i] = p[i + 1]; p[i] = '\\0';&#125;void InsForSubscrip(Number *p, int subscrip, char value)&#123; int i = p-&gt;len - 1; for(; i &gt;= subscrip; i--) &#123; p-&gt;value[i + 1] = p-&gt;value[i]; &#125; p-&gt;value[i + 1] = value; p-&gt;len++;&#125;void Format(Number *p)&#123; int i = p-&gt;len - 1; int j = 1; for(;i &gt;= 0; i--) &#123; if((j % 3 == 0) &amp;&amp; (i != 0)) InsForSubscrip(p, i, ','); j++; &#125;&#125;char Compare(char *p1,char *p2)&#123; int i = 0; while(i &lt; a.len) &#123; if(p1[i] &gt; p2[i]) return 0; else return 1; i++; &#125;&#125;void Addition(Number *p1, Number *p2)&#123; int j = 0; int i = p1-&gt;len - 1; while(i &gt;= 0) &#123; sum.value[j] = (p1-&gt;value[i] - '0') + (p2-&gt;value[i] - '0'); j++; i--; &#125; sum.len = p1-&gt;len; Carry(sum.value); sum.pn = p1-&gt;pn;&#125;void Carry(char *p)&#123; //*****初始化sum.value为0 int i = 0; while(i &lt; sum.len) &#123; if(p[i] &gt;= 10) &#123; p[i + 1] += 1; p[i] = (p[i] % 10) + '0'; &#125; else p[i] += '0'; i++; &#125; if(p[i] == 1) &#123; p[i] += '0'; sum.len += 1; &#125;&#125;void ReversalStr(char *p)&#123; char len = strlen(p); char e = len; len--; char i = 0; char tmp = 0; while(i &lt; e / 2) &#123; tmp = p[i]; p[i] = p[len]; p[len] = tmp; i++; len--; &#125;&#125;void Subtraction(Number *p1, Number *p2)&#123; int i = p1-&gt;len - 1; int j = 0; while(i &gt;= 0) &#123; if(p1-&gt;value[i] &gt;= p2-&gt;value[i]) &#123; sum.value[j] = (p1-&gt;value[i] - '0') - (p2-&gt;value[i] - '0') + '0'; &#125; else &#123; p1-&gt;value[i - 1] -= 1; sum.value[j] = (p1-&gt;value[i] - '0') - (p2-&gt;value[i] - '0') + 10 + '0'; &#125; i--; j++; &#125; if(sum.value[j - 1] == '0') &#123; sum.value[p1-&gt;len - 1] = '\\0'; sum.len = p1-&gt;len - 1; &#125; else sum.len = p1-&gt;len; sum.pn = p1-&gt;pn;&#125;void Operation()&#123; if(a.pn == b.pn) Addition(&amp;a, &amp;b); else if(Compare(a.value, b.value) == 0) //p1 - p2 Subtraction(&amp;a, &amp;b); else //p2 - p1 Subtraction(&amp;b, &amp;a); ReversalStr(sum.value); Format(&amp;sum); //正序格式&#125;int Output(Number *p)&#123; int i = 0; while(i &lt; p-&gt;len) &#123; if(p-&gt;value[i] != '0') break; i++; &#125; if(i == p-&gt;len) &#123; putchar('0'); return 0; &#125; if(p-&gt;pn == 0) &#123; putchar('-'); puts(p-&gt;value); &#125; else puts(p-&gt;value);&#125; 测试链接click me","tags":[{"name":"PAT","slug":"PAT","permalink":"http://turingxi.top/tags/PAT/"},{"name":"C","slug":"C","permalink":"http://turingxi.top/tags/C/"}]}]